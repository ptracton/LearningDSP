#+LaTex_HEADER: \usepackage{listings}

* Statistics, Probability and Noise
** Signals and Graph Terminology
*** Definitions
- *Signal* is how one parameter is related to another parameter
- *Continuous Signal* is if BOTH parameters can assume a continuous range
- *Discrete Signal* is if BOTH parameters are quantized in some manner
- *Time Domain* is if the X axis (the independent variable) is time
- *Frequency Domain* is if the X axis (the independent variable) is frequency
*** Concepts
- The two parameters of a signal are not interchangeable
- The parameter on the Y axis is a function of the one on the X axis
- Mathematicians tend to do 1-N, everyone else does 0-(N-1)
** Mean and Standard Deviation
*** Mean
- *Mean* \mu is the average of the signal.  Add all samples together and divide by N. In electronics this is the DC (direct current) value.

$$\mu = \frac{1}{N}\sum_{i=1}^{N-1}x_{i}$$

#+BEGIN_SRC python :session :results output
import random
samples = random.sample(range(1, 101), 20)
def Mean(data=None):
    """
    Calculate the mean of a list of values.
    """
    if data is None:
        return
    mean = 0
    for x in data:
       mean = mean + x
       mean = mean/len(data)
    return mean

samples

Mean(samples)

#+END_SRC

#+RESULTS: 
: [78, 15, 37, 22, 51, 90, 86, 62, 68, 29, 52, 28, 49, 21, 73, 89, 79, 38, 66, 50]
: 2

*** Standard Deviation and Variance
- *Average Deviation* is not commonly used.  Sums up all the deviations, from the mean, for each sample and divided by the number of samples.  Use absolute values for deviation otherwise differences could cancel out.
- *Standard Deviation* averages the power.  This is the AC portion of the signal.  
$$\sigma = \sqrt{\frac{1}{N-1}\sum_{i=1}^{N-1} (x_{i} - \mu)^{2}}$$ 

#+BEGIN_SRC python :session :results output
import math
def StandardDeviation(samples):
    """
    Calculate the standard deviation of a list of values.
    Uses the Mean method from previous examples
    """
    mean = Mean(samples)
    std = 0.0
    for x in samples:
        std = std + math.pow((x - mean), 2)
        std = std / (len(samples) - 1)
        std = math.sqrt(std)
    return std

samples

StandardDeviation(samples)
#+END_SRC

#+RESULTS: 
: [78, 83, 38, 63, 35, 55, 82, 99, 7, 43]
: 12.849613134796984



- *Variance*  is commonly used in statistics.  Notice variance and standard deviation both divide by N-1, not N!  
$$\sigma^{2} = \frac{1}{N-1}\sum_{i=1}^{N-1} (x_{i} - \mu)^{2}$$

#+BEGIN_SRC python :session :results output

def Variance(samples):
    """
    Calculate the variance of a list of values.
    """
    return math.pow(StandardDeviation(samples), 2)

samples

Variance(samples)
#+END_SRC

#+RESULTS: 
: [78, 83, 38, 63, 35, 55, 82, 99, 7, 43]
: 165.11255771394718

- *Root Mean Square (rms)* measures both the AC and DC components.
$$x_{rms} = \sqrt{\frac{1}{N}\sum_{i=0}^{N-1} (x_{i})^{2}}$$ 

#+BEGIN_SRC python :session :results output
def RootMeanSquare(samples):
    """
    Calculate the Root Mean Square of an input list
    """
    rms = 0
    N = len(samples)
    for x in range(N-1):
        square = samples[x] * samples[x]
    divide = square/N
    rms = math.sqrt(divide)
    return rms

samples

RootMeanSquare(samples)
#+END_SRC

#+RESULTS:
: [63, 48, 33, 13, 75, 34, 44, 99, 27, 20, 30, 32, 85, 77, 55, 70, 21, 86, 45, 67]
: 10.04987562112089

*** Running Statistics
- *Running Statistics* is often needed.  In this situation we want to recompute mean and standard deviation of new signal added in without redoing all of the calculations

$$
\sigma^{2} = \frac{1}{N-1} ( \sum_{i=0}^{N-1}(x_{i})^2 - \frac{1}{N}(\sum_{i=0}^{N-1} x_{i})^2)
$$


#+BEGIN_SRC python :session :results output
def RunningStatistics(samples):
    """
    Calculate the mean, variance and std while running through a list of
    values. The self.samples list should be set when instantiating
    this instance.
    """
    mean = 0
    variance = 0
    std = 0
    temp_sum = 0
    sum_squares = 0
    N = len(samples)
    for x in samples:
        temp_sum = temp_sum + x
        sum_squares = sum_squares + math.pow(x, 2)
        mean = temp_sum/N
        variance = (sum_squares - (math.pow(temp_sum, 2)/N)) / (N - 1)
        std = math.sqrt(variance)
    return mean, variance, std    

samples

RunningStatistics(samples)
#+END_SRC

#+RESULTS:
: [92, 65, 22, 1, 39, 57, 73, 28, 95, 21]
: (49.3, 1024.2333333333331, 32.003645625667914)

- In some situations mean decribes what is being measured and standard deviation measures noise
- *Signal to Noise Ration (SNR)* is a comparison of mean to standard deviation

$$
SNR = \frac{\mu}{\sigma}
$$
#+BEGIN_SRC python :session :results output
def SNR(samples):
    """
    Calculate the Signal to Noise Ratio 
    """
    SNR = Mean(samples)/StandardDeviation(samples)
    return SNR

samples

SNR(samples)
#+END_SRC

#+RESULTS:
: [100, 33, 43, 22, 72, 5, 6, 46, 95, 48]
: 0.4086576025773104

- *Coefficient of Variance (CV)* is the standard deviation divided by the mean and multiplied by 100%.

$$
CV = \frac{\sigma}{\mu} * 100\%
$$
#+BEGIN_SRC python :session :results output

def CV(samples):
    """
    Calculate the Signal to Coefficient of Variation
    """
    CV = (StandardDeviation(samples)/Mean(samples)) * 100
    return CV

samples

CV(samples)
#+END_SRC

#+RESULTS:
: [10, 74, 92, 51, 76, 25, 52, 22, 9, 49, 61, 40, 62, 28, 87, 63, 26, 81, 71, 3]
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 5, in CV
: ZeroDivisionError: float division by zero

- High SNR and Low CV is a good signal!

** Signal vs. Underlying Process
- *Statistics* is the science of interpreting numerical data 
- *Probability* is used in DSP to understand the process that generated the signals
- *Statistical Variation or Fluctuation or Noise* is random irregularity found in actual data
- *Typical Error* is the standard deviation over the square root of the number of samples.  For small N, expect a large error. As N grows larger the error should be shrinking.
$$
Typical Error = \frac{\sigma}{N^\frac{1}{2}}
$$


- *Strong Law of Large Numbers* guarantees that the error becomes zero as N approaches infinity.
- The Standard Deviation equation measures the value of the underlying process, not the actual signal.  Divide through by N to get the value of the signal.
- *Non Stationary* processes that change their underlying behavior.  This causes a slowly changing mean and standard deviation.  
** The Histogram, PMF and PDF
- *Histogram* displays the number of samples there are in the signal at this value or range of values.

#+NAME: python-histogram
#+BEGIN_SRC python  :results file
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt

mu, sigma = 100, 15
x = mu + sigma * np.random.randn(10000)

# the histogram of the data
n, bins, patches = plt.hist(x, 50, normed=1, facecolor='green', alpha=0.75)

# add a 'best fit' line
y = mlab.normpdf(bins, mu, sigma)
l = plt.plot(bins, y, 'r--', linewidth=1)

foo = plt.xlabel('Smarts')
foo = plt.ylabel('Probability')
foo = plt.title(r'$\mathrm{Histogram\ of\ IQ:}\ \mu=100,\ \sigma=15$')
foo = plt.axis([40, 160, 0, 0.03])
foo = plt.grid(True)
foo = plt.savefig('../Notes/histogram.png', bbox_inches='tight')
#+END_SRC

#+CAPTION: Histogram graph example
#+NAME:   fig:HISTOGRAM
[[file:../Notes/histogram.png]]




** The Normal Distribution
** Digital Noise Generation
** Precision and Accuracy

